Index: main.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os\"\r\n\t\"sstable/LSM\"\r\n\t\"sstable/SSTableStruct/SSTable\"\r\n\t\"sstable/iterator\"\r\n\t\"sstable/lru\"\r\n\t\"sstable/mem/memtable/hash/hashmem\"\r\n\t\"sstable/mem/memtable/hash/hashstruct\"\r\n\t\"sstable/scanning\"\r\n\t\"sstable/token_bucket\"\r\n\t\"sstable/wal_implementation\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar compress1 bool\r\nvar compress2 bool\r\nvar oneFile bool\r\nvar number int\r\nvar N int\r\nvar M int\r\nvar memTableCap int\r\nvar memType string\r\nvar walSegmentSize int\r\nvar key, value string\r\nvar rate, maxToken int64\r\n\r\ntype Config struct {\r\n\tLruCap         int    `json:\"lru_cap\"`\r\n\tCompress1      bool   `json:\"compress1\"`\r\n\tCompress2      bool   `json:\"compress2\"`\r\n\tOneFile        bool   `json:\"oneFile\"`\r\n\tNumber         int    `json:\"numberOfSSTable\"`\r\n\tN              int    `json:\"N\"` // razudjenost u indexu\r\n\tM              int    `json:\"M\"` // razudjenost u summary\r\n\tMemTableCap    int    `json:\"memTableCap\"`\r\n\tMemType        string `json:\"memType\"`\r\n\tWalSegmentSize int    `json:\"walSegmentSize\"`\r\n}\r\n\r\nfunc setConst() {\r\n\tvar config Config\r\n\r\n\tconfigData, err := os.ReadFile(\"config.json\")\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\terr = json.Unmarshal(configData, &config)\r\n\tif err != nil {\r\n\t\tlog.Fatal(err)\r\n\t}\r\n\tfmt.Println(config)\r\n\tcompress1 = config.Compress1\r\n\tcompress2 = config.Compress2\r\n\toneFile = config.OneFile\r\n\tnumber = config.Number\r\n\tN = config.N\r\n\tM = config.M\r\n\tmemTableCap = config.MemTableCap\r\n\tmemType = config.MemType\r\n\twalSegmentSize = config.WalSegmentSize\r\n\r\n}\r\n\r\nfunc GET(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, mem1 *hashmem.Memtable, key string) {\r\n\t////ukoliko je GET\r\n\tok, value := (*mem1).GetElement(key)\r\n\tif ok {\r\n\t\tfmt.Printf(\"Value: %s\\n\", value)\r\n\t}\r\n\r\n\tvalue = lru1.Get(key)\r\n\tif value != nil {\r\n\t\tfmt.Printf(\"Value: %s\\n\", value)\r\n\t}\r\n\r\n\tdata, ok := LSM.GetByKey(key, compress1, compress2, oneFile)\r\n\tif ok {\r\n\t\tfmt.Printf(\"Value: %s\\n\", data.GetData())\r\n\t} else {\r\n\t\tfmt.Printf(\"Nema ga\\n\")\r\n\t}\r\n\r\n}\r\n\r\n// Ukoliko je unos PUT\r\nfunc PUT(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, mem1 *hashmem.Memtable, key string, value []byte) {\r\n\r\n\t//Prvo u WAL\r\n\terr := wal.Log(key, value, false)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\t//Drugo u mem\r\n\r\n\tif (*mem1).IsReadOnly() {\r\n\t\t(*mem1).SendToSSTable(compress1, compress2, oneFile, N, M)\r\n\t}\r\n\t//LSM.CompactSstable(number, compress1, compress2, oneFile)\r\n\r\n\tok := (*mem1).AddElement(key, value)\r\n\tif !ok {\r\n\t\tpanic(\"Greska\")\r\n\t}\r\n\t// kada je put ne ide u LRU\r\n}\r\n\r\nfunc DELETE(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, mem1 *hashmem.Memtable, key string) {\r\n\t//Ukoliko je unos DELETE\r\n\r\n\terr := wal.Log(key, []byte(\"\"), true)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tok := (*mem1).DeleteElement(key)\r\n\tif ok {\r\n\t\tfmt.Printf(\"Obrisan iz mem1\")\r\n\t} else {\r\n\t\tfmt.Printf(\"Nije u mem1\")\r\n\t}\r\n\r\n\tlru1.Delete(key)\r\n}\r\n\r\nfunc meni(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, mem *hashmem.Memtable, tokenb *token_bucket.TokenBucket) {\r\n\tfor true {\r\n\t\tvar opcija string\r\n\t\tfmt.Println(\"Key-Value Engine\")\r\n\r\n\t\tfmt.Println(\"\\n1. Put\\n2. Delete\\n3. Get\\n4. Skeniranje\\n5. Izlaz\\n\")\r\n\t\tfmt.Printf(\"Unesite opciju : \")\r\n\t\t_, err := fmt.Scan(&opcija)\r\n\t\tif err != nil {\r\n\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\treturn\r\n\t\t}\r\n\t\tmess, moze := tokenb.IsRequestAllowed(9)\r\n\t\tif !moze {\r\n\t\t\tfmt.Printf(mess + \"\\n\")\r\n\t\t\tcontinue\r\n\t\t}\r\n\r\n\t\tif opcija == \"1\" {\r\n\t\t\tfmt.Printf(\"Unesite key : \")\r\n\t\t\t_, err := fmt.Scan(&key)\r\n\t\t\tif err != nil {\r\n\t\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tfmt.Printf(\"Unesite value : \")\r\n\t\t\t_, err = fmt.Scan(&value)\r\n\t\t\tif err != nil {\r\n\t\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tPUT(wal, lru1, mem, key, []byte(value))\r\n\t\t} else if opcija == \"2\" {\r\n\t\t\tfmt.Printf(\"Unesite key : \")\r\n\t\t\t_, err := fmt.Scan(&key)\r\n\t\t\tif err != nil {\r\n\t\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tDELETE(wal, lru1, mem, key)\r\n\t\t} else if opcija == \"3\" {\r\n\t\t\tfmt.Printf(\"Unesite key : \")\r\n\t\t\t_, err := fmt.Scan(&key)\r\n\t\t\tif err != nil {\r\n\t\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tGET(wal, lru1, mem, key)\r\n\t\t} else if opcija == \"4\" {\r\n\t\t\tfor true {\r\n\t\t\t\tfmt.Println(\"\\n1. Range scan\\n2. Prefix Scan\\n3. Range iterate\\n4. Prefix iterate\\n\")\r\n\t\t\t\tvar opcijaSken string\r\n\t\t\t\tfmt.Printf(\"Unesite opciju : \")\r\n\t\t\t\t_, err := fmt.Scan(&opcijaSken)\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\tfmt.Println(\"Error:\", err)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\tif opcijaSken == \"1\" {\r\n\t\t\t\t\tfmt.Printf(\"range sken\")\r\n\t\t\t\t} else if opcijaSken == \"2\" {\r\n\t\t\t\t\tfmt.Printf(\"pref sken\")\r\n\t\t\t\t} else if opcijaSken == \"3\" {\r\n\t\t\t\t\tfmt.Printf(\"range iter\")\r\n\t\t\t\t} else if opcijaSken == \"4\" {\r\n\t\t\t\t\tfmt.Printf(\"pref sken\")\r\n\t\t\t\t} else if opcijaSken == \"5\" {\r\n\t\t\t\t\tfmt.Printf(\"Izlazak..\\n\")\r\n\t\t\t\t\tbreak\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfmt.Printf(\"Izabrali ste pogresnu opcjiu.\\n\")\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t} else if opcija == \"5\" {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tfmt.Printf(\"Izabrali ste pogresnu opciju.\\n\")\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nfunc main() {\r\n\t//setConst()\r\n\t//wal := wal_implementation.NewWriteAheadLog()\r\n\t//rate = 3\r\n\t//maxToken = 10\r\n\t//tokenb := token_bucket.NewTokenBucket(rate, maxToken)\r\n\t//tokenb.InitRequestsFile(\"token_bucket/requests.bin\")\r\n\t////mem1 := btreemem.NewBTreeMemtable(10)\r\n\t//lru1 := lru.NewLRUCache(3)\r\n\t//var mem hashmem.Memtable\r\n\t//if memType == \"hash\" {\r\n\t//\tmem = hashstruct.CreateHashMemtable(10)\r\n\t//} else if memType == \"skipl\" {\r\n\t//\tmem = skiplistmem.CreateSkipListMemtable(10)\r\n\t//} else {\r\n\t//\tmem = btreemem.NewBTreeMemtable(10)\r\n\t//}\r\n\t//\r\n\t//meni(wal, lru1, &mem, tokenb)\r\n\t//cursor := cursor2.NewCursor(mem, 0, lru1)\r\n\t//\r\n\t//cursor.MemPointers()[cursor.MemIndex()]\r\n\t//\r\n\t//Read a single line of input\r\n\t//\r\n\t//fmt.Println(\"You entered:\", key, value, []byte(value))\r\n\r\n\t//for i := 0; i < 10; i++ {\r\n\t//\terr := wal.Log(strconv.Itoa(i), []byte(strconv.Itoa(i)), false)\r\n\t//\tif err != nil {\r\n\t//\t\tpanic(err)\r\n\t//\t}\r\n\t//\tmem1.AddElement(strconv.Itoa(i), []byte(strconv.Itoa(i)))\r\n\t//}\r\n\t//wal := wal_implementation.NewWriteAheadLog()\r\n\t//for i := 0; i < 10; i++ {\r\n\t//\tkey := \"kljuc\" + strconv.Itoa(i)\r\n\t//\tvalue_string := \"vrednost\" + strconv.Itoa(i)\r\n\t//\tvalue := []byte(value_string)\r\n\t//\twal.Log(key, value, false)\r\n\t//}\r\n\t//err := wal.DeleteSegmentsTilWatermark()\r\n\t//if err != nil {\r\n\t//\tfmt.Println(err)\r\n\t//}\r\n\t//records, err := wal.ReadAllRecords()\r\n\t//if err != nil {\r\n\t//\tfmt.Println(err)\r\n\t//}\r\n\t//for _, rec := range records {\r\n\t//\tfmt.Println(rec)\r\n\t//}\r\n\r\n\tcompress1 := true\r\n\tcompress2 := true\r\n\toneFile := true\r\n\tN := 1\r\n\tM := 1\r\n\tmemTableCap := 10\r\n\r\n\tm := 10\r\n\tvar mapMem map[*hashmem.Memtable]int\r\n\tprefix := \"1\"\r\n\tmapMem = make(map[*hashmem.Memtable]int)\r\n\r\n\tfor i := 0; i < 10; i++ {\r\n\t\tbtmem := hashmem.Memtable(hashstruct.CreateHashMemtable(m))\r\n\t\tmapMem[&btmem] = 0\r\n\t\tfor j := 0; j < 10; j++ {\r\n\t\t\tbtmem.AddElement(strconv.Itoa(j), []byte(strconv.Itoa(j)))\r\n\t\t}\r\n\t\tbtmem.DeleteElement(strconv.Itoa(15))\r\n\t\tbtmem.SendToSSTable(compress1, compress2, oneFile, N, M)\r\n\t\t//SSTable.ReadIndex(\"DataSSTable/L0/sstable\"+strconv.Itoa(i+1), compress1, compress2, 2, oneFile)\r\n\t\t//SSTable.ReadIndex(\"DataSSTable/L0/sstable\"+strconv.Itoa(i+1), compress1, compress2, 3, oneFile)\r\n\t\tLSM.CompactSstable(10, compress1, compress2, oneFile, N, M, memTableCap, \"level\")\r\n\r\n\t}\r\n\r\n\tLSM.CompactSstable(10, compress1, compress2, oneFile, N, M, memTableCap, \"level\")\r\n\tfmt.Printf(\"Konacna: \\n\")\r\n\tSSTable.ReadSSTable(\"DataSSTable/L1/sstable1\", compress1, compress2, oneFile)\r\n\t//SSTable.ReadIndex(\"DataSSTable/L1/sstable1/Summary.bin\", compress1, compress2, 2, oneFile)\r\n\t//SSTable.ReadIndex(\"DataSSTable/L1/sstable1\", compress1, compress2, 3, oneFile)\r\n\t//key := \"9\"\r\n\t////scanning.PrefixIterateSSTable(\"ad\", false)\r\n\t//fmt.Printf(\"Sumary: \")\r\n\t////SSTable.ReadIndex(\"DataSSTable/L1/sstable1\", compress1, compress2, 2, oneFile)\r\n\t//data, err4 := LSM.GetByKey(key, compress1, compress2, oneFile)\r\n\t//if err4 == true {\r\n\t//\tfmt.Printf(\"Key: %s\\n\", data.GetKey())\r\n\t//\tfmt.Printf(\"Value: %s\\n\", data.GetData())\r\n\t//\tfmt.Printf(\"Time: %s\\n\", data.GetChangeTime())\r\n\t//} else {\r\n\t//\tfmt.Printf(\"Ne postoji podatak sa kljucem %s\\n\", key)\r\n\t//}\r\n\t//Ne brisi, iter test\r\n\titerMem := iterator.NewPrefixIterator(mapMem, prefix)\r\n\titerSSTable := scanning.PrefixIterateSSTable(prefix, compress2, compress1, oneFile)\r\n\tscanning.PREFIX_ITERATE(prefix, iterMem, iterSSTable, compress1, compress2, oneFile)\r\n\t//kraj\r\n\t//fmt.Printf(\"Konacna: \\n\")\r\n\t//SSTable.ReadSSTable(\"DataSSTable/L1/sstable1\", compress1, compress2, oneFile)\r\n\t//SSTable.ReadIndex(\"DataSSTable/L1/sstable1/Summary.bin\", compress1, compress2, 2, oneFile)\r\n\t//SSTable.ReadIndex(\"DataSSTable/L1/sstable1\", compress1, compress2, 3, oneFile)\r\n\t//key := \"9\"\r\n\t////scanning.PrefixIterateSSTable(\"ad\", false)\r\n\t//fmt.Printf(\"Sumary: \")\r\n\t////SSTable.ReadIndex(\"DataSSTable/L1/sstable1\", compress1, compress2, 2, oneFile)\r\n\t//data, err4 := LSM.GetByKey(key, compress1, compress2, oneFile)\r\n\t//if err4 == true {\r\n\t//\tfmt.Printf(\"Key: %s\\n\", data.GetKey())\r\n\t//\tfmt.Printf(\"Value: %s\\n\", data.GetData())\r\n\t//\tfmt.Printf(\"Time: %s\\n\", data.GetChangeTime())\r\n\t//} else {\r\n\t//\tfmt.Printf(\"Ne postoji podatak sa kljucem %s\\n\", key)\r\n\t//}\r\n\t//lista, _, _, _ := LSM.GetDataByPrefix(15, \"2\", compress1, compress2, oneFile)\r\n\t//for _, i2 := range lista {\r\n\t//\tfmt.Printf(\"Key: %s \", i2.GetKey())\r\n\t//\tfmt.Printf(\"Value: %s\\n\", i2.GetData())\r\n\t//}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.go b/main.go
--- a/main.go	(revision c3c014b9dd6be1352c1f935f55b31ba2602ebabc)
+++ b/main.go	(date 1706733884330)
@@ -277,10 +277,11 @@
 
 	for i := 0; i < 10; i++ {
 		btmem := hashmem.Memtable(hashstruct.CreateHashMemtable(m))
-		mapMem[&btmem] = 0
+
 		for j := 0; j < 10; j++ {
 			btmem.AddElement(strconv.Itoa(j), []byte(strconv.Itoa(j)))
 		}
+		mapMem[&btmem] = 0
 		btmem.DeleteElement(strconv.Itoa(15))
 		btmem.SendToSSTable(compress1, compress2, oneFile, N, M)
 		//SSTable.ReadIndex("DataSSTable/L0/sstable"+strconv.Itoa(i+1), compress1, compress2, 2, oneFile)
@@ -289,6 +290,11 @@
 
 	}
 
+	btm := hashmem.Memtable(hashstruct.CreateHashMemtable(m))
+	for j := 0; j < 10; j++ {
+		btm.AddElement(strconv.Itoa(j), []byte(strconv.Itoa(j)))
+	}
+	mapMem[&btm] = 0
 	LSM.CompactSstable(10, compress1, compress2, oneFile, N, M, memTableCap, "level")
 	fmt.Printf("Konacna: \n")
 	SSTable.ReadSSTable("DataSSTable/L1/sstable1", compress1, compress2, oneFile)
