Index: cursor/cursor.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package cursor\r\n\r\nimport (\r\n\t\"encoding/binary\"\r\n\t\"sstable/LSM\"\r\n\t\"sstable/lru\"\r\n\t\"sstable/mem/memtable/btree/btreemem\"\r\n\t\"sstable/mem/memtable/hash/hashmem\"\r\n\t\"sstable/mem/memtable/hash/hashstruct\"\r\n\t\"sstable/mem/memtable/skiplist/skiplistmem\"\r\n\t\"sstable/wal_implementation\"\r\n\t\"time\"\r\n)\r\n\r\ntype Cursor struct {\r\n\tmemPointers []hashmem.Memtable //lista pokazivaca na memtabele\r\n\tmaxMem      int                // maksimalan Broj memtabela\r\n\tmemIndex    int                // broj metabele koja je trenutno aktivna\r\n\tlruPointer  *lru.LRUCache      // pokazivac na kes\r\n\r\n\tcompress1   bool   // da li je ukljucena kompresija duzine\r\n\tcompress2   bool   // da li je ukljucena kompresija sa recnikom\r\n\toneFile     bool   // da li se SSTable cuva u jednom fajlu\r\n\tN           int    // razudjenost Index-a\r\n\tM           int    // razudjenost Summary-ja\r\n\tnumTables   int    // broj SSTabela na nivou\r\n\tmemCap      int    //kapacitet memtabele\r\n\tcompType    string //koja kompakcija se koristi\r\n\tmaxSSTLevel int    //maksimalan broj nivoa za SStable\r\n\tlevelPlus   int\r\n}\r\n\r\nfunc NewCursor(memType string, maxMem int, lruPointer *lru.LRUCache, compress1 bool, compress2 bool, oneFile bool, n int, m int, numTables int, memCap int, compType string, maxSSTLevel, levelPlus int) *Cursor {\r\n\tmemPointers := make([]hashmem.Memtable, maxMem)\r\n\tfor i := 0; i < maxMem; i++ {\r\n\t\tif memType == \"hash\" {\r\n\t\t\tmemPointers[i] = hashstruct.CreateHashMemtable(memCap)\r\n\t\t} else if memType == \"skipl\" {\r\n\t\t\tmemPointers[i] = skiplistmem.CreateSkipListMemtable(memCap)\r\n\t\t} else if memType == \"btree\" {\r\n\t\t\tmemPointers[i] = btreemem.NewBTreeMemtable(memCap)\r\n\t\t} else {\r\n\t\t\tmemPointers[i] = btreemem.NewBTreeMemtable(memCap)\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn &Cursor{\r\n\t\tmemPointers: memPointers,\r\n\t\tmaxMem:      maxMem,\r\n\t\tmemIndex:    0,\r\n\t\tlruPointer:  lruPointer,\r\n\t\tcompress1:   compress1,\r\n\t\tcompress2:   compress2,\r\n\t\toneFile:     oneFile,\r\n\t\tN:           n,\r\n\t\tM:           m,\r\n\t\tnumTables:   numTables,\r\n\t\tmemCap:      memCap,\r\n\t\tcompType:    compType,\r\n\t\tmaxSSTLevel: maxSSTLevel,\r\n\t\tlevelPlus:   levelPlus,\r\n\t}\r\n}\r\n\r\nfunc (c *Cursor) Compress1() bool {\r\n\treturn c.compress1\r\n}\r\n\r\nfunc (c *Cursor) SetCompress1(compress1 bool) {\r\n\tc.compress1 = compress1\r\n}\r\n\r\nfunc (c *Cursor) Compress2() bool {\r\n\treturn c.compress2\r\n}\r\n\r\nfunc (c *Cursor) SetCompress2(compress2 bool) {\r\n\tc.compress2 = compress2\r\n}\r\n\r\nfunc (c *Cursor) OneFile() bool {\r\n\treturn c.oneFile\r\n}\r\n\r\nfunc (c *Cursor) SetOneFile(oneFile bool) {\r\n\tc.oneFile = oneFile\r\n}\r\n\r\nfunc (c *Cursor) MaxMem() int {\r\n\treturn c.maxMem\r\n}\r\n\r\nfunc (c *Cursor) SetMaxMem(maxMem int) {\r\n\tc.maxMem = maxMem\r\n}\r\n\r\nfunc (c *Cursor) MemPointers() []hashmem.Memtable {\r\n\treturn c.memPointers\r\n}\r\n\r\nfunc (c *Cursor) SetMemPointers(memPointers []hashmem.Memtable) {\r\n\tc.memPointers = memPointers\r\n}\r\n\r\nfunc (c *Cursor) MemIndex() int {\r\n\treturn c.memIndex\r\n}\r\n\r\nfunc (c *Cursor) SetMemIndex(memIndex int) {\r\n\tc.memIndex = memIndex\r\n}\r\n\r\nfunc (c *Cursor) LruPointer() *lru.LRUCache {\r\n\treturn c.lruPointer\r\n}\r\n\r\nfunc (c *Cursor) SetLruPointer(lruPointer *lru.LRUCache) {\r\n\tc.lruPointer = lruPointer\r\n}\r\n\r\nfunc (c *Cursor) AddToMemtable(key string, value []byte, time time.Time, wal *wal_implementation.WriteAheadLog) bool {\r\n\tvar full bool\r\n\tfull = false\r\n\r\n\tj, find := c.findElement(key)\r\n\tif !find {\r\n\t\tif c.memPointers[c.memIndex].IsReadOnly() {\r\n\t\t\tc.memIndex = (c.memIndex + 1) % len(c.memPointers)\r\n\t\t\tif c.memPointers[c.memIndex].IsReadOnly() {\r\n\t\t\t\tc.memIndex = (c.memIndex - 1 + c.maxMem) % c.maxMem\r\n\t\t\t\tc.memPointers[c.memIndex].SendToSSTable(c.Compress1(), c.Compress2(), c.OneFile(), c.N, c.M, c.maxSSTLevel)\r\n\t\t\t\tLSM.CompactSstable(c.numTables, c.Compress1(), c.Compress2(), c.OneFile(), c.N, c.M, c.memCap, c.compType, c.maxSSTLevel, c.levelPlus)\r\n\t\t\t\t//Salje se signal u WAL da je memtable upisana na disk\r\n\t\t\t\terr := wal.DeleteMemTable()\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\tfull = c.memPointers[c.memIndex].AddElement(key, value, time)\r\n\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tfull = c.memPointers[c.memIndex].AddElement(key, value, time)\r\n\t\t}\r\n\r\n\t} else {\r\n\t\tc.memPointers[j].UpdateElement(key, value, time)\r\n\t}\r\n\r\n\t//ako se memtable popunio salje se signal u WAL\r\n\tif full {\r\n\t\tc.memIndex = (c.memIndex + 1) % c.maxMem\r\n\t\terr := wal.EndMemTable()\r\n\t\tif err != nil {\r\n\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunc (c *Cursor) findElement(key string) (int, bool) {\r\n\r\n\tvar find bool\r\n\r\n\tfind = false\r\n\tj := c.memIndex\r\n\tfor true {\r\n\t\tfind, _ = c.memPointers[j].GetElement(key)\r\n\t\tif find {\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tj = (j - 1 + c.maxMem) % c.maxMem\r\n\t\tif j == c.memIndex {\r\n\t\t\tbreak\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn j, find\r\n}\r\n\r\nfunc (c *Cursor) GetElement(key string) ([]byte, bool) {\r\n\r\n\tvar value []byte\r\n\r\n\tj, find := c.findElement(key)\r\n\r\n\tif find {\r\n\t\t_, value = c.memPointers[j].GetElement(key)\r\n\t}\r\n\r\n\treturn value, find\r\n}\r\n\r\nfunc (c *Cursor) DeleteElement(key string, time time.Time) bool {\r\n\tj, find := c.findElement(key)\r\n\r\n\tif find {\r\n\t\tc.memPointers[j].DeleteElement(key, time)\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n\r\n}\r\n\r\nfunc (c *Cursor) Fill(wal *wal_implementation.WriteAheadLog) {\r\n\tfor true {\r\n\t\trec, err := wal.ReadRecord()\r\n\t\tif err != \"\" {\r\n\t\t\tif err == \"NO MORE RECORDS\" {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tif err != \"CRC FAILED!\" {\r\n\t\t\tnano := int64(binary.BigEndian.Uint64(rec.Timestamp[8:]))\r\n\t\t\ttimestamp := time.Unix(nano, 0)\r\n\t\t\tc.AddToMemtable(rec.Key, rec.Value, timestamp, wal)\r\n\t\t}\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cursor/cursor.go b/cursor/cursor.go
--- a/cursor/cursor.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/cursor/cursor.go	(date 1707060139154)
@@ -5,6 +5,7 @@
 	"sstable/LSM"
 	"sstable/lru"
 	"sstable/mem/memtable/btree/btreemem"
+	"sstable/mem/memtable/datatype"
 	"sstable/mem/memtable/hash/hashmem"
 	"sstable/mem/memtable/hash/hashstruct"
 	"sstable/mem/memtable/skiplist/skiplistmem"
@@ -123,7 +124,7 @@
 	var full bool
 	full = false
 
-	j, find := c.findElement(key)
+	find, _ := c.memPointers[c.memIndex].GetElement(key)
 	if !find {
 		if c.memPointers[c.memIndex].IsReadOnly() {
 			c.memIndex = (c.memIndex + 1) % len(c.memPointers)
@@ -137,14 +138,13 @@
 					return false
 				}
 				full = c.memPointers[c.memIndex].AddElement(key, value, time)
-
 			}
 		} else {
 			full = c.memPointers[c.memIndex].AddElement(key, value, time)
 		}
-
 	} else {
-		c.memPointers[j].UpdateElement(key, value, time)
+		c.memPointers[c.memIndex].UpdateElement(key, value, time)
+
 	}
 
 	//ako se memtable popunio salje se signal u WAL
@@ -161,9 +161,7 @@
 
 func (c *Cursor) findElement(key string) (int, bool) {
 
-	var find bool
-
-	find = false
+	find := false
 	j := c.memIndex
 	for true {
 		find, _ = c.memPointers[j].GetElement(key)
@@ -176,31 +174,26 @@
 		}
 
 	}
-
 	return j, find
 }
 
 func (c *Cursor) GetElement(key string) ([]byte, bool) {
 
-	var value []byte
+	var value *datatype.DataType
 
 	j, find := c.findElement(key)
 
 	if find {
 		_, value = c.memPointers[j].GetElement(key)
 	}
-
-	return value, find
+	if value.IsDeleted() {
+		return []byte(""), false
+	}
+	return value.GetData(), find
 }
 
 func (c *Cursor) DeleteElement(key string, time time.Time) bool {
-	j, find := c.findElement(key)
-
-	if find {
-		c.memPointers[j].DeleteElement(key, time)
-		return true
-	}
-	return false
+	return c.memPointers[c.memIndex].DeleteElement(key, time)
 
 }
 
Index: config.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\"lruCap\": 3,\r\n  \"compress\": true,\r\n  \"dictEncoding\" : true,\r\n  \"oneFile\": false,\r\n  \"numberOfSSTable\": 5,\r\n  \"summaryEl\": 4,\r\n  \"memTableNumber\" : 2,\r\n  \"memTableCap\": 3,\r\n  \"memType\": \"hash\",\r\n  \"walSegmentSize\": 2000,\r\n  \"rate\": 3,\r\n  \"maxToken\": 10,\r\n  \"compType\": \"size\",\r\n  \"maxSSTLevel\": 4,\r\n  \"levelPlus\" : 12\r\n}\r\n\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config.json b/config.json
--- a/config.json	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/config.json	(date 1707059170976)
@@ -1,18 +1,19 @@
 {"lruCap": 3,
   "compress": true,
   "dictEncoding" : true,
-  "oneFile": false,
+  "oneFile": true,
   "numberOfSSTable": 5,
-  "summaryEl": 4,
+  "indexEl": 50,
+  "summaryEl": 10,
   "memTableNumber" : 2,
-  "memTableCap": 3,
-  "memType": "hash",
+  "memTableCap": 5,
+  "memType": "btree",
   "walSegmentSize": 2000,
-  "rate": 3,
+  "rate": 5,
   "maxToken": 10,
   "compType": "size",
-  "maxSSTLevel": 4,
-  "levelPlus" : 12
+  "maxSSTLevel": 5,
+  "levelPlus" : 2
 }
 
 
Index: mem/memtable/btree/btreemem/btreememstruct.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package btreemem\r\n\r\nimport (\r\n\t\"sstable/LSM\"\r\n\t\"sstable/SSTableStruct/SSTable\"\r\n\t\"sstable/mem/memtable/btree/btree\"\r\n\t\"sstable/mem/memtable/datatype\"\r\n\t\"time\"\r\n)\r\n\r\ntype BTreeMemtable struct {\r\n\tdata             *btree.BTree\r\n\tcapacity, length int\r\n\treadOnly         bool\r\n}\r\n\r\nfunc (B *BTreeMemtable) Data() *btree.BTree {\r\n\treturn B.data\r\n}\r\n\r\nfunc (B *BTreeMemtable) SetData(data *btree.BTree) {\r\n\tB.data = data\r\n}\r\n\r\nfunc (B *BTreeMemtable) Capacity() int {\r\n\treturn B.capacity\r\n}\r\n\r\nfunc (B *BTreeMemtable) SetCapacity(capacity int) {\r\n\tB.capacity = capacity\r\n}\r\n\r\nfunc (B *BTreeMemtable) Length() int {\r\n\treturn B.length\r\n}\r\n\r\nfunc (B *BTreeMemtable) SetLength(length int) {\r\n\tB.length = length\r\n}\r\n\r\nfunc (B *BTreeMemtable) ReadOnly() bool {\r\n\treturn B.readOnly\r\n}\r\n\r\nfunc (B *BTreeMemtable) SetReadOnly(readOnly bool) {\r\n\tB.readOnly = readOnly\r\n}\r\n\r\nfunc NewBTreeMemtable(capacity int) *BTreeMemtable {\r\n\treturn &BTreeMemtable{\r\n\t\tdata:     btree.NewBTree(4),\r\n\t\tcapacity: capacity,\r\n\t\tlength:   0,\r\n\t\treadOnly: false,\r\n\t}\r\n}\r\n\r\nfunc (btmem *BTreeMemtable) UpdateElement(key string, data []byte, time time.Time) {\r\n\tbtmem.data.Update(key, data, time)\r\n}\r\n\r\nfunc (btmem *BTreeMemtable) AddElement(key string, data []byte, time time.Time) bool {\r\n\r\n\t//ukoliko ima mesta u memtable, samo se upisuje podatak\r\n\tif btmem.length < btmem.capacity {\r\n\t\te := datatype.CreateDataType(key, data, time)\r\n\t\tbtmem.data.Insert(e)\r\n\t\tbtmem.length++\r\n\r\n\t\t//ako je popunjen, postavlja se na read only\r\n\t}\r\n\tif btmem.length == btmem.capacity {\r\n\t\tbtmem.readOnly = true\r\n\t}\r\n\tif btmem.IsReadOnly() {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (btmem *BTreeMemtable) GetElement(key string) (bool, []byte) {\r\n\telem, err := btmem.data.Search(key)\r\n\tif !err || elem.IsDeleted() {\r\n\t\treturn false, nil\r\n\t}\r\n\treturn true, elem.GetData()\r\n}\r\nfunc (btmem *BTreeMemtable) GetMaxSize() int {\r\n\treturn btmem.length\r\n}\r\nfunc (btmem *BTreeMemtable) DeleteElement(key string, time time.Time) bool {\r\n\tfound := btmem.data.Delete(key, time)\r\n\treturn found\r\n}\r\nfunc (btmem *BTreeMemtable) GetSortedDataTypes() []datatype.DataType {\r\n\tdataList := btmem.SortDataTypes()\r\n\treturn dataList\r\n}\r\nfunc (btmem *BTreeMemtable) SortDataTypes() []datatype.DataType {\r\n\tdataList := make([]datatype.DataType, btmem.length)\r\n\tdataList = btmem.data.Traverse()\r\n\treturn dataList\r\n}\r\n\r\nfunc (btmem *BTreeMemtable) SendToSSTable(compress1, compress2, oneFile bool, N, M, maxSSTlevel int) bool {\r\n\r\n\tdataList := btmem.SortDataTypes()\r\n\r\n\tnewSstableName, _ := LSM.FindNextDestination(0, maxSSTlevel)\r\n\tSSTable.NewSSTable(dataList, N, M, newSstableName, compress1, compress2, oneFile)\r\n\tSSTable.ReadSSTable(newSstableName, compress1, compress2)\r\n\r\n\tbtmem.data = btree.NewBTree(btmem.capacity)\r\n\tbtmem.length = 0\r\n\tbtmem.readOnly = false\r\n\r\n\treturn true\r\n}\r\n\r\nfunc (btmem *BTreeMemtable) IsReadOnly() bool {\r\n\treturn btmem.ReadOnly()\r\n}\r\n\r\nfunc (btmem *BTreeMemtable) GetElementByPrefix(dataList []*datatype.DataType, n *int, prefix string) {\r\n\tbtmem.data.GetByPrefix(dataList[:], n, prefix)\r\n}\r\nfunc (btmem *BTreeMemtable) GetElementByRange(dataList []*datatype.DataType, n *int, valRange []string) {\r\n\tbtmem.data.GetByRange(dataList[:], n, valRange)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mem/memtable/btree/btreemem/btreememstruct.go b/mem/memtable/btree/btreemem/btreememstruct.go
--- a/mem/memtable/btree/btreemem/btreememstruct.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/mem/memtable/btree/btreemem/btreememstruct.go	(date 1707059857317)
@@ -78,12 +78,12 @@
 	return false
 }
 
-func (btmem *BTreeMemtable) GetElement(key string) (bool, []byte) {
+func (btmem *BTreeMemtable) GetElement(key string) (bool, *datatype.DataType) {
 	elem, err := btmem.data.Search(key)
-	if !err || elem.IsDeleted() {
+	if !err {
 		return false, nil
 	}
-	return true, elem.GetData()
+	return true, elem
 }
 func (btmem *BTreeMemtable) GetMaxSize() int {
 	return btmem.length
Index: main.go
===================================================================
diff --git a/main.go b/main.go
deleted file mode 100644
--- a/main.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ /dev/null	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
@@ -1,1100 +0,0 @@
-package main
-
-import (
-	"encoding/json"
-	"fmt"
-	"log"
-	"os"
-	"sstable/LSM"
-	"sstable/MerkleTreeImplementation/MerkleTree"
-	"sstable/SSTableStruct/SSTable"
-	SimHash "sstable/SimHashImplementation"
-	"sstable/bloomfilter/bloomfilter"
-	count_min_sketch "sstable/cms"
-	"sstable/cursor"
-	"sstable/hyperloglog/hyperloglog"
-	"sstable/iterator"
-	"sstable/lru"
-	"sstable/mem/memtable/hash/hashmem"
-	"sstable/mem/memtable/hash/hashstruct"
-	"sstable/scanning"
-	"sstable/token_bucket"
-	"sstable/wal_implementation"
-	"strconv"
-	"strings"
-	"time"
-)
-
-var compress1 bool
-var compress2 bool
-var oneFile bool
-var NumberOfSST, lruCap int
-var N int
-var M int
-var memTableCap, memTableNumber, levelPlus int
-var memType, compType string
-var walSegmentSize, maxSSTLevel int
-var rate, maxToken int64
-var key, value string
-
-type Config struct {
-	LruCap         int    `json:"lruCap"`
-	Compress1      bool   `json:"compress"`
-	Compress2      bool   `json:"dictEncoding"`
-	OneFile        bool   `json:"oneFile"`
-	NumberOfSST    int    `json:"numberOfSSTable"`
-	N              int    `json:"indexEl"`   // razudjenost u indexu
-	M              int    `json:"summaryEl"` // razudjenost u summary
-	MemTableNumber int    `json:"memTableNumber"`
-	MemTableCap    int    `json:"memTableCap"`
-	MemType        string `json:"memType"`
-	WalSegmentSize int    `json:"walSegmentSize"`
-	Rate           int64  `json:"rate"`
-	MaxToken       int64  `json:"maxToken"`
-	CompType       string `json:"compType"`
-	MaxSSTLevel    int    `json:"maxSSTLevel"`
-	LevelPlus      int    `json:"levelPlus"`
-}
-
-func setConst() {
-	var config Config
-
-	configData, err := os.ReadFile("config.json")
-	if err != nil {
-		panic(err)
-	}
-
-	err = json.Unmarshal(configData, &config)
-	if err != nil {
-		log.Fatal(err)
-	}
-	//provera postojnja u congi.json
-	var dataResult map[string]interface{}
-
-	err = json.Unmarshal(configData, &dataResult)
-	if err != nil {
-		fmt.Println(err)
-	}
-	// chech for lru
-	_, ok := dataResult["lruCap"]
-	if ok {
-		lruCap = config.LruCap
-		if lruCap <= 0 {
-			lruCap = 2
-		}
-	} else {
-		lruCap = 2
-	}
-
-	// compress1
-	_, ok = dataResult["compress"]
-	if ok {
-		compress1 = config.Compress1
-	} else {
-		compress1 = false
-	}
-	//compress2
-	_, ok = dataResult["dictEncoding"]
-	if ok {
-		compress2 = config.Compress2
-	} else {
-		compress2 = false
-	}
-	//oneFile
-	_, ok = dataResult["oneFile"]
-	if ok {
-		oneFile = config.OneFile
-	} else {
-		oneFile = false
-	}
-	//numOfSST
-	_, ok = dataResult["numberOfSSTable"]
-	if ok {
-		NumberOfSST = config.NumberOfSST
-		if NumberOfSST <= 0 {
-			NumberOfSST = 3
-		}
-	} else {
-		NumberOfSST = 5
-	}
-
-	//memTableNum
-	_, ok = dataResult["memTableNumber"]
-	if ok {
-		memTableNumber = config.MemTableNumber
-		if memTableNumber <= 0 {
-			memTableNumber = 2
-		}
-	} else {
-		memTableNumber = 2
-	}
-
-	//memCap
-	_, ok = dataResult["memTableCap"]
-	if ok {
-		memTableCap = config.MemTableCap
-		if memTableCap <= 0 {
-			memTableCap = 5
-		}
-	} else {
-		memTableCap = 5
-	}
-	//indexEl
-	_, ok = dataResult["indexEl"]
-	if ok {
-		N = config.N
-	} else {
-		N = memTableCap / 3
-	}
-	if N <= 0 || N >= memTableCap {
-		N = 1
-	}
-	//summaruEl
-	_, ok = dataResult["summaryEl"]
-	if ok {
-		M = config.M
-	} else {
-		M = memTableCap / 2
-	}
-	if M <= 0 || M >= memTableCap {
-		M = 1
-	}
-	if M < N {
-		M = N + 1
-	}
-
-	//memType
-	_, ok = dataResult["memType"]
-	if ok {
-		memType = config.MemType
-		if memType != "hash" && memType != "btree" && memType != "skipl" {
-			memType = "hash"
-		}
-	} else {
-		memType = "hash"
-	}
-
-	//wal
-	_, ok = dataResult["walSegmentSize"]
-	if ok {
-		walSegmentSize = config.WalSegmentSize
-	} else {
-		walSegmentSize = 2000
-	} //provera uradjena u wal-u
-	//rateForLRU
-	_, ok = dataResult["rate"]
-	if ok {
-		rate = config.Rate
-		if rate <= 0 {
-			rate = 2
-		}
-	} else {
-		rate = 3
-	}
-
-	//maxToken
-	_, ok = dataResult["maxToken"]
-	if ok {
-		maxToken = config.MaxToken
-		if maxToken <= 0 {
-			maxToken = 10
-		}
-	} else {
-		maxToken = 10
-	}
-
-	//compType
-	_, ok = dataResult["compType"]
-	if ok {
-		compType = config.CompType
-		if compType != "size" && compType != "level" {
-			compType = "size"
-		}
-	} else {
-		compType = "size"
-	}
-	//maxSSTVelev
-	_, ok = dataResult["maxSSTLevel"]
-	if ok {
-		maxSSTLevel = config.MaxSSTLevel
-		if maxSSTLevel <= 0 {
-			maxSSTLevel = 3
-		}
-	} else {
-		maxSSTLevel = 4
-	}
-	//levelPlus
-	_, ok = dataResult["levelPlus"]
-	if ok {
-		levelPlus = config.LevelPlus
-		if levelPlus <= 0 {
-			levelPlus = 10
-		}
-	} else {
-		levelPlus = 12
-	}
-
-}
-
-func checkKey(key string) (bool, string) {
-	noKey := [5]string{"bf", "hll", "cms", "sh", ""}
-	splitKey := strings.Split(key, "_")
-	index := len(splitKey) - 1
-	for i := 0; i < len(noKey); i++ {
-		if splitKey[index] == noKey[i] {
-			return false, noKey[i]
-		}
-	}
-	return true, ""
-
-}
-
-func ValidateSSTable(sstablePath string) {
-	fmt.Println("---------------------------------------------------")
-	merkleTreePath := SSTable.DeserializeMerkleFromSST(sstablePath)
-	merkleTree1, _, err := MerkleTree.DeserializeMerkleTree(merkleTreePath)
-	if err != nil {
-		panic(err)
-	}
-	_, merkleTreeByte := SSTable.ReadSSTable(sstablePath, compress1, compress2)
-	merkleTree2, _ := MerkleTree.CreateMerkleTree(merkleTreeByte)
-
-	change, _ := MerkleTree.CheckChanges(merkleTree1, merkleTree2)
-
-	if len(change) > 0 {
-		fmt.Println("\nIma promene")
-		for i := 0; i < len(change); i++ {
-			fmt.Printf("Podataka na indexu %d. je promenjen.\n", int(change[i]))
-		}
-	} else {
-		fmt.Println("\nNema promene")
-	}
-
-}
-
-func GET(lru1 *lru.LRUCache, memtable *cursor.Cursor, key string) ([]byte, bool) {
-	////ukoliko je GET
-	value, ok := memtable.GetElement(key)
-	if ok {
-		fmt.Printf("Value: %s\n", value)
-		return value, true
-	}
-
-	value = lru1.Get(key)
-	if value != nil {
-		fmt.Printf("Value: %s\n", value)
-		return value, true
-	}
-
-	data, ok := LSM.GetByKey(key, compress1, compress2, oneFile)
-	if ok && data.GetKey() != "" {
-		fmt.Printf("Value: %s\n", data.GetData())
-		return data.GetData(), ok
-	} else if data.GetKey() == "" && ok {
-		fmt.Printf("Postoji greska u podacima!\n")
-		return data.GetData(), false
-	} else {
-		fmt.Printf("Nema ga\n")
-		return nil, false
-	}
-
-}
-
-func PUT(wal *wal_implementation.WriteAheadLog, memtable *cursor.Cursor, key string, value []byte) {
-
-	//Prvo u WAL
-	timestamp := time.Now()
-	err := wal.Log(key, value, false, timestamp)
-	if err != nil {
-		panic(err)
-	}
-	//Drugo u mem
-
-	ok := memtable.AddToMemtable(key, value, timestamp, wal)
-	if !ok {
-		panic("Greska")
-	}
-	// kada je put ne ide u LRU
-}
-
-func DELETE(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor, key string) {
-	//Ukoliko je unos DELETE
-	timestamp := time.Now()
-	err := wal.LogDelete(key, timestamp)
-	if err != nil {
-		panic(err)
-	}
-	ok := memtable.DeleteElement(key, timestamp)
-	if ok {
-		fmt.Printf("Obrisan")
-	} else {
-		//zapis se dodaje u memtable kao nov sa detele na true
-		ok = memtable.AddToMemtable(key, []byte(""), timestamp, wal)
-		fmt.Printf("Obrisan ")
-	}
-
-	lru1.Delete(key)
-}
-
-func TypeBloomFilter(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor) {
-	option := "-1"
-	for option != "5" {
-		fmt.Println("Rad sa BloomFilter tipom: ")
-		fmt.Println("\n1. Kreiranje nove instance\n2. Brisanje postojece instance\n3. Dodavanje elementa u postojecu instancu\n4. Provera da li je element u nekoj instanci\n5. Izlaz\n")
-		fmt.Printf("Unesite opciju : ")
-		_, err := fmt.Scan(&option)
-		if err != nil {
-			fmt.Println("Error:", err)
-			return
-		}
-		if option == "1" {
-			var key string
-			fmt.Println("Unesite kljuc: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_bf"
-
-			_, found := GET(lru1, memtable, key)
-			if found {
-				fmt.Printf("Vec postoji element sa tim kljucem!")
-			} else {
-				var n int
-				fmt.Println("Unesite duzinu BloomFilter-a: ")
-				_, err := fmt.Scan(&n)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				bf := bloomfilter.CreateBloomFilter(uint64(n))
-				serializedData, _ := bloomfilter.SerializeBloomFilter(bf)
-				PUT(wal, memtable, key, serializedData)
-				fmt.Printf("BloomFilter je upisan u sistem!")
-			}
-		}
-		if option == "2" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_bf"
-			_, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				DELETE(wal, lru1, memtable, key)
-				fmt.Printf("BloomFilter sa izabranim kljucem je uspesno obrisan!")
-			}
-		}
-		if option == "3" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_bf"
-			data, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				bf, _ := bloomfilter.DeserializeBloomFilter(data)
-				var value []byte
-				fmt.Println("Unesite vrednost koju unosite u BloomFilter: ")
-				_, err := fmt.Scan(&value)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				(*bf).Set(value)
-				serializedData, _ := bloomfilter.SerializeBloomFilter(bf)
-				PUT(wal, memtable, key, serializedData)
-				fmt.Printf("Vrednost je uneta u BloomFilter!")
-			}
-		}
-		if option == "4" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_bf"
-			data, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				bf, _ := bloomfilter.DeserializeBloomFilter(data)
-				var value []byte
-				fmt.Println("Unesite vrednost koju trazite u BloomFilter-u: ")
-				_, err := fmt.Scan(&value)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				found := (*bf).Get(value)
-				if !found {
-					fmt.Println("Vrednost se sigurno ne nalazi u BloomFilter-u!")
-				} else {
-					fmt.Println("Vrednost se mozda nalazi u BloomFilter-u!")
-				}
-			}
-		}
-		if option == "5" {
-			break
-		} else {
-			fmt.Printf("Uneli ste nepostojecu opciju!")
-		}
-	}
-}
-
-func TypeCountMinSketch(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor) {
-	option := "-1"
-	for option != "5" {
-		fmt.Println("Rad sa CountMinSketch tipom: ")
-		fmt.Println("\n1. Kreiranje nove instance\n2. Brisanje postojece instance\n3. Dodavanje dogadjaja u postojecu instancu\n4. Provera ucestalosti dogadjaja u nekoj instanci\n5. Izlaz\n")
-		fmt.Printf("Unesite opciju : ")
-		_, err := fmt.Scan(&option)
-		if err != nil {
-			fmt.Println("Error:", err)
-			return
-		}
-		if option == "1" {
-			var key string
-			fmt.Println("Unesite kljuc: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_cms"
-			_, found := GET(lru1, memtable, key)
-			if found {
-				fmt.Printf("Vec postoji element sa tim kljucem!")
-			} else {
-				var width, hashes int
-				fmt.Println("Unesite sirinu CountMinSketch tabele:  ")
-				_, err := fmt.Scan(&width)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				fmt.Println("Unesite broj HASH funkcija CountMinSketch-a:  ")
-				_, err = fmt.Scan(&hashes)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				cms := count_min_sketch.NewCountMinSketch(width, hashes)
-				serializedData, _ := cms.SerializeCountMinSketch()
-				PUT(wal, memtable, key, serializedData)
-				fmt.Printf("Novi CountMinSketch je uspesno upisan u sistem!")
-			}
-		}
-		if option == "2" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_cms"
-			_, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				DELETE(wal, lru1, memtable, key)
-				fmt.Printf("CountMinSketch sa izabranim kljucem je uspesno obrisan!")
-			}
-		}
-		if option == "3" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_cms"
-			data, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				cms, _ := count_min_sketch.DeserializeCountMinSketch(data)
-				var value string
-				fmt.Println("Unesite vrednost dogadjaja koji unosite u CountMinSketch: ")
-				_, err := fmt.Scan(&value)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				(*cms).Update(value)
-				serializedData, _ := (*cms).SerializeCountMinSketch()
-				PUT(wal, memtable, key, serializedData)
-				fmt.Printf("Vrednost je uneta u CountMinSketch!")
-			}
-		}
-		if option == "4" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_cms"
-			data, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				cms, _ := count_min_sketch.DeserializeCountMinSketch(data)
-				var value string
-				fmt.Println("Unesite vrednost dogadjaja iz CountMinSketch-a cija vas ucestanost zanima: ")
-				_, err := fmt.Scan(&value)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				frequency := (*cms).Estimate(value)
-				fmt.Printf("Ucestanost unete vrednosti u CountMinSketch-u: %v", frequency)
-			}
-		}
-		if option == "5" {
-			break
-		} else {
-			fmt.Printf("Uneli ste nepostojecu opciju!")
-		}
-	}
-}
-
-func TypeHyperLogLog(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor) {
-	option := "-1"
-	for option != "5" {
-		fmt.Println("Rad sa HyperLogLog tipom: ")
-		fmt.Println("\n1. Kreiranje nove instance\n2. Brisanje postojece instance\n3. Dodavanje elementa u postojecu instancu\n4. Provera kardinaliteta\n5. Izlaz\n")
-		fmt.Printf("Unesite opciju : ")
-		_, err := fmt.Scan(&option)
-		if err != nil {
-			fmt.Println("Error:", err)
-			return
-		}
-		if option == "1" {
-			var key string
-			fmt.Println("Unesite kljuc: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_hll"
-			_, found := GET(lru1, memtable, key)
-			if found {
-				fmt.Printf("Vec postoji element sa tim kljucem!")
-			} else {
-				var n uint64
-				fmt.Println("Unesite duzinu seta HyperLogLog-a: ")
-				_, err := fmt.Scan(&n)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				hll := hyperloglog.CreateHyperLogLog(n)
-				serializedData, _ := hyperloglog.SerializeHyperLogLog(hll)
-				PUT(wal, memtable, key, serializedData)
-				fmt.Printf("HyperLogLog je upisan u sistem!")
-			}
-		}
-		if option == "2" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_hll"
-			_, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				DELETE(wal, lru1, memtable, key)
-				fmt.Printf("HyperLogLog sa izabranim kljucem je uspesno obrisan!")
-			}
-		}
-		if option == "3" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_hll"
-			data, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				hll, _ := hyperloglog.DeserializeHyperLogLog(data)
-				var value []byte
-				fmt.Println("Unesite vrednost koju unosite u HyperLogLog: ")
-				_, err := fmt.Scan(&value)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				(*hll).Add(value)
-				serializedData, _ := hyperloglog.SerializeHyperLogLog(hll)
-				PUT(wal, memtable, key, serializedData)
-				fmt.Printf("Vrednost je uneta u HyperLogLog!")
-			}
-		}
-		if option == "4" {
-			var key string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_hll"
-			data, found := GET(lru1, memtable, key)
-			if !found {
-				fmt.Printf("Ne postoji element sa tim kljucem!")
-			} else {
-				hll, _ := hyperloglog.DeserializeHyperLogLog(data)
-				fmt.Printf("Kardinalitet izabrane instance HyperLogLog-a: %v", (*hll).CountHLL())
-			}
-		}
-		if option == "5" {
-			break
-		} else {
-			fmt.Printf("Uneli ste nepostojecu opciju!")
-		}
-	}
-}
-
-func TypeSimHash(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor) {
-	option := "-1"
-	for option != "3" {
-		fmt.Println("Rad sa SimHash tipom: ")
-		fmt.Println("\n1. Cuvanje fingerprinta prosledjenog teksta\n2.Racunanje Hemingove udaljenosti dva fingerprinta\n3. Izlaz\n")
-		fmt.Printf("Unesite opciju : ")
-		_, err := fmt.Scan(&option)
-		if err != nil {
-			fmt.Println("Error:", err)
-			return
-		}
-		if option == "1" {
-			var key string
-			fmt.Println("Unesite kljuc: ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key += "_sh"
-			_, found := GET(lru1, memtable, key)
-			if found {
-				fmt.Printf("Vec postoji element sa tim kljucem!")
-			} else {
-				var text string
-				fmt.Println("Unesite tekst za cuvanje: ")
-				_, err := fmt.Scan(&text)
-				if err != nil {
-					fmt.Println("Error:", err)
-					return
-				}
-				sh := SimHash.NewSimHash(text)
-				value := sh.ReturnIdArray()
-				PUT(wal, memtable, key, value)
-				fmt.Printf("SimHash je upisan u sistem!")
-			}
-		}
-		if option == "2" {
-			var key1, key2 string
-			fmt.Println("Unesite kljuc postojece instance: ")
-			_, err := fmt.Scan(&key1)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			_, err = fmt.Scan(&key2)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key1)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key1 += "_sh"
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr = checkKey(key1)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				return
-			}
-			key2 += "_sh"
-			data1, found1 := GET(lru1, memtable, key1)
-			data2, found2 := GET(lru1, memtable, key2)
-			if !found1 || !found2 {
-				fmt.Printf("Jedan ili oba kljuca ne postoje u sistemu!")
-			} else {
-				fmt.Printf("Hemingovo rastojanje izmedju dva izabrana fingerprinta: %v", SimHash.HammingDistance(data1, data2))
-			}
-		}
-		if option == "3" {
-			break
-		} else {
-			fmt.Printf("Uneli ste nepostojecu opciju!")
-		}
-	}
-}
-
-func Scan(cursor *cursor.Cursor) {
-	for true {
-		fmt.Println("\n1. Prefix scan\n2. Range Scan\n3. Prefix iterate\n4. Range iterate\n5. Izlazak iz skeniranja")
-
-		var opcijaSken string
-		fmt.Printf("Unesite opciju >> ")
-		_, err := fmt.Scan(&opcijaSken)
-		if err != nil {
-			fmt.Println("Error:", err)
-			return
-		}
-		if opcijaSken == "1" {
-			var prefix string
-			var strana int
-			var brojNaStrani int
-			fmt.Println("Unesite preifx >> ")
-			_, err = fmt.Scan(&prefix)
-			if err != nil {
-				panic(err)
-			}
-			iteratorSSTable := scanning.PrefixIterateSSTable(prefix, compress1, compress2, oneFile)
-			iteratorMem := iterator.NewPrefixIterator(cursor, prefix)
-
-			fmt.Println("Koja stranica po redu: ")
-			_, err = fmt.Scan(&strana)
-			if err != nil {
-				panic(err)
-			}
-
-			fmt.Println("Broj zapisa po strani: ")
-			_, err = fmt.Scan(&brojNaStrani)
-			if err != nil {
-				panic(err)
-			}
-
-			scanning.PREFIX_SCAN_OUTPUT(prefix, strana, brojNaStrani, iteratorMem, iteratorSSTable, cursor.Compress1(), cursor.Compress2(), cursor.OneFile())
-
-		} else if opcijaSken == "2" {
-			var rangeVal [2]string
-			var strana int
-			var brojNaStrani int
-			fmt.Println("Unesite odakle >> ")
-			_, err = fmt.Scan(&rangeVal[0])
-			if err != nil {
-				panic(err)
-			}
-			fmt.Println("Unesite dokle >> ")
-			_, err = fmt.Scan(&rangeVal[1])
-			if err != nil {
-				panic(err)
-			}
-			iteratorSSTable := scanning.RangeIterateSSTable(rangeVal, compress1, compress2, oneFile)
-			iteratorMem := iterator.NewRangeIterator(cursor, rangeVal)
-
-			fmt.Println("Koja stranica po redu: ")
-			_, err = fmt.Scan(&strana)
-			if err != nil {
-				panic(err)
-			}
-
-			fmt.Println("Broj zapisa po strani: ")
-			_, err = fmt.Scan(&brojNaStrani)
-			if err != nil {
-				panic(err)
-			}
-
-			scanning.RANGE_SCAN_OUTPUT(rangeVal, strana, brojNaStrani, iteratorMem, iteratorSSTable, cursor.Compress1(), cursor.Compress2(), cursor.OneFile())
-
-		} else if opcijaSken == "3" {
-			fmt.Printf("range iter")
-		} else if opcijaSken == "4" {
-			fmt.Printf("pref sken")
-		} else if opcijaSken == "5" {
-			fmt.Printf("Izlazak..\n")
-			break
-		} else {
-			fmt.Printf("\nIzabrali ste pogresnu opcjiu.")
-		}
-
-	}
-}
-
-func Types(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor) {
-
-	for true {
-		fmt.Println("\n1. Bloomfilter\n2.Count min sketch\n3. Hyperloglog\n4. Simhash\n5. Izlaz")
-		var opcijaTip string
-		_, err := fmt.Scan(&opcijaTip)
-		if err != nil {
-			panic(err)
-		}
-		if opcijaTip == "1" {
-			TypeBloomFilter(wal, lru1, memtable)
-		} else if opcijaTip == "2" {
-			TypeCountMinSketch(wal, lru1, memtable)
-		} else if opcijaTip == "3" {
-			TypeHyperLogLog(wal, lru1, memtable)
-		} else if opcijaTip == "4" {
-			TypeSimHash(wal, lru1, memtable)
-		} else if opcijaTip == "5" {
-			fmt.Println("\nIzlazak iz opcije tipovi.")
-			return
-		} else {
-			fmt.Println("\nIzabrali ste nepostojecu opciju. Pokusajte ponovo.")
-		}
-	}
-}
-
-func meni(wal *wal_implementation.WriteAheadLog, lru1 *lru.LRUCache, memtable *cursor.Cursor, tokenb *token_bucket.TokenBucket) {
-	for true {
-		var opcija string
-		fmt.Println("Key-Value Engine")
-
-		fmt.Println("\n1. Unesi podatak\n2. Obrisi podatak\n3. Dobavi podatak\n4. Skeniranje\n5. Tipovi\n6. Proveri SSTabelu\n7. Izlaz")
-		fmt.Printf("Unesite opciju >> ")
-		_, err := fmt.Scan(&opcija)
-		if err != nil {
-			fmt.Println("Error:", err)
-			return
-		}
-		mess, moze := tokenb.IsRequestAllowed(9)
-		if !moze {
-			fmt.Printf("\n" + mess + "\n")
-			continue
-		}
-
-		if opcija == "1" {
-			fmt.Printf("Unesite kljuc >> ")
-			_, err := fmt.Scan(&key)
-
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				continue
-			}
-			fmt.Printf("Unesite vrednost >> ")
-			_, err = fmt.Scan(&value)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			PUT(wal, memtable, key, []byte(value))
-			//TODO test
-		} else if opcija == "2" {
-			fmt.Printf("Unesite kljuc >> ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				continue
-			}
-			DELETE(wal, lru1, memtable, key)
-			//TODO test
-		} else if opcija == "3" {
-			fmt.Printf("Unesite kljuc >> ")
-			_, err := fmt.Scan(&key)
-			if err != nil {
-				fmt.Println("Error:", err)
-				return
-			}
-			//provera da li KEY sadrzi neku od kljucnih reci na kraju reci
-			ok, kr := checkKey(key)
-			if !ok {
-				fmt.Printf("Koristite kljucnu rec %s\n", kr)
-				continue
-			}
-			GET(lru1, memtable, key)
-			//TODO test
-		} else if opcija == "4" {
-			Scan(memtable)
-		} else if opcija == "5" {
-			Types(wal, lru1, memtable)
-			// TODO test
-		} else if opcija == "6" {
-			fmt.Println("Unesite koj sstabelu zelite da proverite(npr. sstable1) >> ")
-			var sstableName, sstablePath string
-			_, err = fmt.Scan(&sstableName)
-			if err != nil {
-				panic(err)
-			}
-			//TODO provera da li sstable posotji
-			ValidateSSTable(sstablePath)
-			//TEST DONE
-
-		} else if opcija == "7" {
-			fmt.Println("\nGasenje programa...")
-			break
-		} else {
-			fmt.Printf("\nIzabrali ste pogresnu opciju. Pokusajte ponovo.")
-		}
-	}
-
-}
-
-func scantest() {
-	var mapMem map[*hashmem.Memtable]int
-	//prefix := "1"
-	mapMem = make(map[*hashmem.Memtable]int)
-
-	j := 0
-
-	for i := 0; i < 5; i++ {
-		btm := hashmem.Memtable(hashstruct.CreateHashMemtable(15))
-		for k := 0; k < 14; k++ {
-			btm.AddElement(strconv.Itoa(k), []byte(strconv.Itoa(k)), time.Now())
-
-		}
-		btm.SendToSSTable(compress1, compress2, oneFile, 2, 3, maxSSTLevel)
-
-	}
-	j = 17
-	for i := 0; i < 5; i++ {
-		btm := hashmem.Memtable(hashstruct.CreateHashMemtable(10))
-		for k := 0; k < 10; k++ {
-			btm.AddElement(strconv.Itoa(j), []byte(strconv.Itoa(j)), time.Now())
-			j++
-		}
-
-		mapMem[&btm] = 0
-	}
-	//iterMem := iterator.NewPrefixIterator(mapMem, prefix)
-	//iterSSTable := scanning.PrefixIterateSSTable(prefix, compress2, compress1, oneFile)
-	//scanning.PREFIX_SCAN_OUTPUT(prefix, 1, 10, iterMem, iterSSTable, compress1, compress2, oneFile)
-	//
-	//for k, _ := range mapMem {
-	//	mapMem[k] = 0
-	//}
-	//j = 0
-	//valRange := [2]string{"1", "2"}
-	//iterMemR := iterator.NewRangeIterator(mapMem, valRange)
-	//iterSSTableR := scanning.RangeIterateSSTable(valRange, compress2, compress1, oneFile)
-	//scanning.RANGE_SCAN_OUTPUT(valRange, 1, 10, iterMemR, iterSSTableR, compress1, compress2, oneFile)
-	fmt.Println("")
-}
-
-func main() {
-	// postavka
-	setConst()
-	//kreiranje potrebnih instanci
-	wal := wal_implementation.NewWriteAheadLog(walSegmentSize)
-	tokenb := token_bucket.NewTokenBucket(rate, maxToken)
-	tokenb.InitRequestsFile("token_bucket/requests.bin")
-	lru1 := lru.NewLRUCache(lruCap)
-	memtable := cursor.NewCursor(memType, memTableNumber, lru1, compress1, compress2, oneFile, N, M, NumberOfSST, memTableCap, compType, maxSSTLevel, levelPlus)
-	memtable.Fill(wal)
-
-	meni(wal, lru1, memtable, tokenb)
-
-}
Index: wal_implementation/wal/wal_00001.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/wal_implementation/wal/wal_00001.log b/wal_implementation/wal/wal_00001.log
deleted file mode 100644
--- a/wal_implementation/wal/wal_00001.log	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ /dev/null	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
@@ -1,1 +0,0 @@
-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
Index: LSM/lsm.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package LSM\r\n\r\nimport (\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"math\"\r\n\t\"math/rand\"\r\n\t\"os\"\r\n\t\"sort\"\r\n\t\"sstable/SSTableStruct/SSTable\"\r\n\t\"sstable/mem/memtable/datatype\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\nfunc FindNextDestination(layer, maxSSTlevel int) (string, bool) {\r\n\r\n\tif layer == maxSSTlevel {\r\n\t\tlayer -= 1\r\n\t}\r\n\tif _, err := os.Stat(\"./DataSStable/L\" + strconv.Itoa(layer)); errors.Is(err, os.ErrNotExist) {\r\n\t\terr := os.Mkdir(\"./DataSStable/L\"+strconv.Itoa(layer), os.ModePerm)\r\n\t\tif err != nil {\r\n\t\t\tpanic(err)\r\n\t\t}\r\n\t}\r\n\tlayerEntries, err := os.ReadDir(\"./DataSStable/L\" + strconv.Itoa(layer))\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\r\n\tnewSstableName := \"./DataSStable/L\" + strconv.Itoa(layer) + \"/sstable\" + strconv.Itoa(len(layerEntries)+1)\r\n\terrMkdir := os.Mkdir(newSstableName, os.ModePerm)\r\n\tif errMkdir != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn newSstableName, false\r\n}\r\n\r\nfunc CompactSstable(numTables int, compres1, compres2, oneFile bool, N, M, memtableCap int, compType string, maxSSTlevel, levelPlus int) {\r\n\r\n\t//ovako za gore u entrijim\r\n\tdataDir, err := os.Open(\"./DataSStable\")\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\terr = dataDir.Close()\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tlayerNames, err := dataDir.Readdirnames(-1)\r\n\tvar compSSTable map[string][]int64\r\n\tif compType == \"size\" {\r\n\r\n\t\tcompSSTable = make(map[string][]int64)\r\n\r\n\t\tfor i, name := range layerNames {\r\n\t\t\tfilelayer, err := os.Open(dataDir.Name() + \"/\" + name)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = filelayer.Close()\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tsstableName, errNames := filelayer.Readdirnames(-1)\r\n\t\t\tif errNames != nil {\r\n\t\t\t\tpanic(errNames)\r\n\t\t\t}\r\n\r\n\t\t\tif len(sstableName) >= numTables {\r\n\t\t\t\tif i+1 < maxSSTlevel {\r\n\t\t\t\t\tif _, err := os.Stat(dataDir.Name() + \"/L\" + strconv.Itoa(i+1)); errors.Is(err, os.ErrNotExist) {\r\n\t\t\t\t\t\terr := os.Mkdir(dataDir.Name()+\"/L\"+strconv.Itoa(i+1), os.ModePerm)\r\n\t\t\t\t\t\tif err != nil {\r\n\t\t\t\t\t\t\tpanic(err)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewSstableName, _ := FindNextDestination(i+1, maxSSTlevel)\r\n\t\t\t\tfmt.Println(newSstableName)\r\n\t\t\t\t//maksimalan broj elemenata u novoj SSTabeli\r\n\t\t\t\tmaxElemSize := memtableCap * int(math.Pow(float64(numTables), float64(i)))\r\n\t\t\t\tfor j := 0; j < len(sstableName); j++ {\r\n\t\t\t\t\ta := make([]int64, 2)\r\n\t\t\t\t\tcompSSTable[dataDir.Name()+\"/L\"+strconv.Itoa(i)+\"/\"+sstableName[j]] = a\r\n\t\t\t\t}\r\n\t\t\t\tSSTable.GetOffsetStartEnd(&compSSTable)\r\n\t\t\t\tSSTable.NewSSTableCompact(newSstableName, compSSTable, N, M, maxElemSize, compres1, compres2, oneFile)\r\n\t\t\t\tfmt.Printf(\"%d\", maxElemSize)\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t} else if compType == \"level\" {\r\n\r\n\t\tfor i, name := range layerNames {\r\n\t\t\tfilelayer, err := os.Open(dataDir.Name() + \"/\" + name)\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\terr = filelayer.Close()\r\n\t\t\tif err != nil {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tsstableName, errNames := filelayer.Readdirnames(-1)\r\n\t\t\tif errNames != nil {\r\n\t\t\t\tpanic(errNames)\r\n\t\t\t}\r\n\r\n\t\t\tif len(sstableName) >= numTables*int(math.Pow(float64(levelPlus), float64(i))) {\r\n\t\t\t\t//jedna tabela sa prethodnog novoa + ostale tabele sa narednog nivoa\r\n\t\t\t\trandSST := rand.Intn(len(sstableName)-1) + 1\r\n\t\t\t\tminData, maxData, _ := SSTable.GetSummaryMinMax(dataDir.Name()+\"/L\"+strconv.Itoa(i)+\"/sstable\"+strconv.Itoa(randSST), compres1, compres2)\r\n\r\n\t\t\t\tcompSSTable = GetSSTableLevelComp(minData, maxData, dataDir.Name()+\"/L\"+strconv.Itoa(i+1), compres1, compres2, oneFile)\r\n\t\t\t\tif compSSTable == nil {\r\n\t\t\t\t\tcompSSTable = make(map[string][]int64)\r\n\t\t\t\t}\r\n\t\t\t\ta := make([]int64, 2)\r\n\t\t\t\tcompSSTable[dataDir.Name()+\"/L\"+strconv.Itoa(i)+\"/sstable\"+strconv.Itoa(randSST)] = a\r\n\t\t\t\tSSTable.GetOffsetStartEnd(&compSSTable)\r\n\r\n\t\t\t\tnewSstableName, _ := FindNextDestination(i+1, maxSSTlevel)\r\n\t\t\t\tmaxElemSize := memtableCap * int(math.Pow(10, float64(i))) * numTables\r\n\t\t\t\tfmt.Printf(\"%d\", maxElemSize)\r\n\t\t\t\tfmt.Println(newSstableName)\r\n\t\t\t\tSSTable.NewSSTableCompact(newSstableName, compSSTable, N, M, maxElemSize, compres1, compres2, oneFile)\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tfor path, _ := range compSSTable {\r\n\t\terr = os.RemoveAll(path)\r\n\t\tfor err != nil {\r\n\t\t\terr = os.RemoveAll(path)\r\n\t\t}\r\n\t}\r\n\tRenameSSTable(numTables)\r\n\r\n}\r\n\r\nfunc GetSSTableLevelComp(minData, maxData datatype.DataType, filePath string, compres1, compres2, oneFile bool) map[string][]int64 {\r\n\tvar compSSTable map[string][]int64\r\n\tcompSSTable = make(map[string][]int64)\r\n\r\n\tfilelayer, err := os.Open(filePath)\r\n\tif err != nil {\r\n\t\treturn compSSTable\r\n\t}\r\n\terr = filelayer.Close()\r\n\tif err != nil {\r\n\t\treturn compSSTable\r\n\t}\r\n\tsstableName, errNames := filelayer.Readdirnames(-1)\r\n\tif errNames != nil {\r\n\t\tpanic(errNames)\r\n\t}\r\n\r\n\tfor _, name := range sstableName {\r\n\t\tcurrentMin, currentMax, _ := SSTable.GetSummaryMinMax(filePath+\"/\"+name, compres1, compres2)\r\n\t\tif currentMin.GetKey() <= minData.GetKey() && currentMax.GetKey() >= minData.GetKey() {\r\n\r\n\t\t\ta := make([]int64, 2)\r\n\t\t\tcompSSTable[filePath+\"/\"+name] = a\r\n\r\n\t\t}\r\n\t\tif minData.GetKey() <= currentMin.GetKey() && maxData.GetKey() >= currentMax.GetKey() {\r\n\r\n\t\t\ta := make([]int64, 2)\r\n\t\t\tcompSSTable[filePath+\"/\"+name] = a\r\n\r\n\t\t}\r\n\t\tif currentMin.GetKey() <= maxData.GetKey() && currentMax.GetKey() >= maxData.GetKey() {\r\n\t\t\ta := make([]int64, 2)\r\n\t\t\tcompSSTable[filePath+\"/\"+name] = a\r\n\t\t}\r\n\t}\r\n\treturn compSSTable\r\n}\r\n\r\nfunc deleteLayer(layerName string) {\r\n\tfile, err := os.Open(layerName)\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\tdirNames, _ := file.Readdirnames(-1)\r\n\tfor _, name := range dirNames {\r\n\t\terr := os.RemoveAll(layerName + \"/\" + name)\r\n\t\tfor err != nil {\r\n\t\t\terr = os.RemoveAll(layerName + \"/\" + name)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc createLayer(layerName string) {\r\n\tif _, err := os.Stat(layerName); errors.Is(err, os.ErrNotExist) {\r\n\t\terr := os.Mkdir(layerName, os.ModePerm)\r\n\t\tif err != nil {\r\n\t\t\tpanic(err)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc RenameSSTable(numTables int) {\r\n\tdataDir, err := os.Open(\"./DataSStable\")\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\terr = dataDir.Close()\r\n\tif err != nil {\r\n\t\treturn\r\n\t}\r\n\tlayerNames, err := dataDir.Readdirnames(-1)\r\n\tfor i, name := range layerNames {\r\n\t\tfilelayer, err := os.Open(dataDir.Name() + \"/\" + name)\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\terr = filelayer.Close()\r\n\t\tif err != nil {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tsstableName, errNames := filelayer.Readdirnames(-1)\r\n\t\tif errNames != nil {\r\n\t\t\tpanic(errNames)\r\n\t\t}\r\n\t\t//preimenovati sve sstabele\r\n\t\tfor _, name = range layerNames {\r\n\t\t\tfilelayer, err = os.Open(dataDir.Name() + \"/\" + name)\r\n\t\t\tif err != nil {\r\n\t\t\t\tpanic(err)\r\n\t\t\t}\r\n\t\t\terr = filelayer.Close()\r\n\t\t\tif err != nil {\r\n\t\t\t\tpanic(err)\r\n\t\t\t}\r\n\t\t\tsstableName, errNames = filelayer.Readdirnames(-1)\r\n\t\t\tif errNames != nil {\r\n\t\t\t\tpanic(errNames)\r\n\t\t\t}\r\n\t\t\tsort.Slice(sstableName, func(i, j int) bool {\r\n\t\t\t\ta, err := strconv.ParseInt(strings.Split(sstableName[i], \"e\")[1], 10, 32)\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\tpanic(err)\r\n\t\t\t\t}\r\n\t\t\t\tb, err := strconv.ParseInt(strings.Split(sstableName[j], \"e\")[1], 10, 32)\r\n\t\t\t\tif err != nil {\r\n\t\t\t\t\tpanic(err)\r\n\t\t\t\t}\r\n\t\t\t\treturn a < b\r\n\t\t\t})\r\n\r\n\t\t\tfor i = 0; i < len(sstableName); i++ {\r\n\t\t\t\tif sstableName[i] != \"sstable\"+strconv.Itoa(i+1) {\r\n\t\t\t\t\terr := os.Rename(dataDir.Name()+\"/\"+name+\"/\"+sstableName[i], dataDir.Name()+\"/\"+name+\"/\"+\"sstable\"+strconv.Itoa(i+1))\r\n\t\t\t\t\tif err != nil {\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LSM/lsm.go b/LSM/lsm.go
--- a/LSM/lsm.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/LSM/lsm.go	(date 1707040836500)
@@ -68,7 +68,7 @@
 				panic(errNames)
 			}
 
-			if len(sstableName) >= numTables {
+			if len(sstableName) >= numTables && i < maxSSTlevel-1 {
 				if i+1 < maxSSTlevel {
 					if _, err := os.Stat(dataDir.Name() + "/L" + strconv.Itoa(i+1)); errors.Is(err, os.ErrNotExist) {
 						err := os.Mkdir(dataDir.Name()+"/L"+strconv.Itoa(i+1), os.ModePerm)
@@ -108,7 +108,7 @@
 				panic(errNames)
 			}
 
-			if len(sstableName) >= numTables*int(math.Pow(float64(levelPlus), float64(i))) {
+			if len(sstableName) >= numTables*int(math.Pow(float64(levelPlus), float64(i))) && i < maxSSTlevel-1 {
 				//jedna tabela sa prethodnog novoa + ostale tabele sa narednog nivoa
 				randSST := rand.Intn(len(sstableName)-1) + 1
 				minData, maxData, _ := SSTable.GetSummaryMinMax(dataDir.Name()+"/L"+strconv.Itoa(i)+"/sstable"+strconv.Itoa(randSST), compres1, compres2)
Index: token_bucket/requests.bin
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>21:57:18, 9, ALLOWED\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/token_bucket/requests.bin b/token_bucket/requests.bin
--- a/token_bucket/requests.bin	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/token_bucket/requests.bin	(date 1707060447622)
@@ -1,1 +1,0 @@
-21:57:18, 9, ALLOWED
Index: mem/memtable/skiplist/skiplistmem/skiplistmemtable.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package skiplistmem\r\n\r\nimport (\r\n\t\"sstable/LSM\"\r\n\t\"sstable/SSTableStruct/SSTable\"\r\n\t\"sstable/mem/memtable/datatype\"\r\n\t\"sstable/mem/memtable/skiplist/skipliststruct\"\r\n\t\"time\"\r\n)\r\n\r\ntype SkipListMemtable struct {\r\n\tdata             *skipliststruct.SkipList\r\n\tcapacity, length int\r\n\treadOnly         bool\r\n}\r\n\r\nfunc CreateSkipListMemtable(cap int) *SkipListMemtable {\r\n\treturn &SkipListMemtable{\r\n\t\tdata:     skipliststruct.CreateSkipList(cap),\r\n\t\tcapacity: cap,\r\n\t\tlength:   0,\r\n\t\treadOnly: false,\r\n\t}\r\n}\r\nfunc (slmem *SkipListMemtable) GetMaxSize() int {\r\n\treturn slmem.length\r\n}\r\nfunc (slmem *SkipListMemtable) GetSortedDataTypes() []datatype.DataType {\r\n\tdataList := slmem.SortDataTypes()\r\n\treturn dataList\r\n}\r\nfunc (slmem *SkipListMemtable) SortDataTypes() []datatype.DataType {\r\n\tdataList := make([]datatype.DataType, slmem.length)\r\n\tdataList = slmem.data.AllData(slmem.length)\r\n\treturn dataList\r\n}\r\n\r\n// funkcija koja ce se implementirati kasnije a sluzi da prosledi podatke iz memtable u SSTable\r\n// i da isprazni memtable kad se podaci posalju\r\nfunc (slmem *SkipListMemtable) SendToSSTable(compress1, compress2, oneFile bool, N, M, maxSSTlevel int) bool {\r\n\r\n\tdataList := make([]datatype.DataType, slmem.length)\r\n\tdataList = slmem.data.AllData(slmem.length)\r\n\r\n\tnewSstableName, _ := LSM.FindNextDestination(0, maxSSTlevel)\r\n\tSSTable.NewSSTable(dataList, N, M, newSstableName, compress1, compress2, oneFile)\r\n\tSSTable.ReadSSTable(newSstableName, compress1, compress2)\r\n\r\n\tslmem.data = skipliststruct.CreateSkipList(slmem.capacity)\r\n\tslmem.length = 0\r\n\tslmem.readOnly = false\r\n\treturn true\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) UpdateElement(key string, data []byte, time time.Time) {\r\n\t_, elem := slmem.data.GetElement(key)\r\n\telem.UpdateDataType(data, time)\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) AddElement(key string, data []byte, time time.Time) bool {\r\n\r\n\t//ukoliko ima mesta u memtable, samo se upisuje podatak\r\n\tif slmem.length < slmem.capacity {\r\n\t\ttemp := datatype.CreateDataType(key, data, time)\r\n\t\tif slmem.data.Insert(temp) == true {\r\n\t\t\tslmem.length++\r\n\t\t}\r\n\r\n\t}\r\n\t//ako je popunjen, postavlja se na read only\r\n\tif slmem.length == slmem.capacity {\r\n\t\tslmem.readOnly = true\r\n\t}\r\n\tif slmem.IsReadOnly() {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n\r\n}\r\nfunc (slmem *SkipListMemtable) GetElement(key string) (bool, []byte) {\r\n\terr, elem := slmem.data.GetElement(key)\r\n\tif err == true {\r\n\t\treturn true, elem.GetData()\r\n\t}\r\n\treturn false, nil\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) DeleteElement(key string, time time.Time) bool {\r\n\tif slmem.data.DeleteElement(key, time) == true {\r\n\t\tslmem.length--\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) ShowSkipList() {\r\n\tslmem.data.ShowSkipList()\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) IsReadOnly() bool {\r\n\treturn slmem.readOnly\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) GetElementByPrefix(resultList []*datatype.DataType, n *int, prefix string) {\r\n\tslmem.data.GetByPrefix(resultList[:], n, prefix)\r\n\r\n}\r\n\r\nfunc (slmem *SkipListMemtable) GetElementByRange(resultList []*datatype.DataType, n *int, valRange []string) {\r\n\tslmem.data.GetByRange(resultList[:], n, valRange)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mem/memtable/skiplist/skiplistmem/skiplistmemtable.go b/mem/memtable/skiplist/skiplistmem/skiplistmemtable.go
--- a/mem/memtable/skiplist/skiplistmem/skiplistmemtable.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/mem/memtable/skiplist/skiplistmem/skiplistmemtable.go	(date 1707059896668)
@@ -77,10 +77,10 @@
 	return false
 
 }
-func (slmem *SkipListMemtable) GetElement(key string) (bool, []byte) {
+func (slmem *SkipListMemtable) GetElement(key string) (bool, *datatype.DataType) {
 	err, elem := slmem.data.GetElement(key)
 	if err == true {
-		return true, elem.GetData()
+		return true, elem
 	}
 	return false, nil
 }
Index: wal_implementation/EndsOfMemtables.bin
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/wal_implementation/EndsOfMemtables.bin b/wal_implementation/EndsOfMemtables.bin
--- a/wal_implementation/EndsOfMemtables.bin	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/wal_implementation/EndsOfMemtables.bin	(date 1707060441781)
@@ -1,0 +1,1 @@
+   $wal_implementation\wal\wal_00001.log     $wal_implementation\wal\wal_00001.log     $wal_implementation\wal\wal_00001.log     $wal_implementation\wal\wal_00001.log     $wal_implementation\wal\wal_00001.log  
\ No newline at end of file
Index: mem/memtable/hash/hashstruct/hashmem.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package hashstruct\r\n\r\nimport (\r\n\t\"sort\"\r\n\t\"sstable/LSM\"\r\n\t\"sstable/SSTableStruct/SSTable\"\r\n\t\"sstable/mem/memtable/datatype\"\r\n\t\"strings\"\r\n\t\"time\"\r\n)\r\n\r\ntype HashMemtable struct {\r\n\tdata             map[string]*datatype.DataType\r\n\tcapacity, length int\r\n\treadOnly         bool\r\n}\r\n\r\nfunc CreateHashMemtable(cap int) *HashMemtable {\r\n\treturn &HashMemtable{\r\n\t\tdata:     make(map[string]*datatype.DataType),\r\n\t\tcapacity: cap,\r\n\t\tlength:   0,\r\n\t\treadOnly: false,\r\n\t}\r\n}\r\nfunc isInRange(value string, valRange []string) bool {\r\n\treturn value >= valRange[0] && value <= valRange[1]\r\n}\r\nfunc (mem *HashMemtable) GetMaxSize() int {\r\n\treturn mem.length\r\n}\r\nfunc (mem *HashMemtable) GetSortedDataTypes() []datatype.DataType {\r\n\tdataList := mem.SortDataTypes()\r\n\treturn dataList\r\n}\r\n\r\n// funkcija koja ce se implementirati kasnije a sluzi da prosledi podatke iz memtable u SSTable\r\n// i da isprazni memtable kad se podaci posalju\r\nfunc (mem *HashMemtable) SortDataTypes() []datatype.DataType {\r\n\tdataList := make([]datatype.DataType, mem.length)\r\n\ti := 0\r\n\tfor _, data := range mem.data {\r\n\t\tdataList[i] = *data\r\n\t\ti++\r\n\t}\r\n\tsort.Slice(dataList, func(i, j int) bool {\r\n\t\treturn dataList[i].GetKey() < dataList[j].GetKey()\r\n\t})\r\n\treturn dataList\r\n\r\n}\r\n\r\nfunc (mem *HashMemtable) SendToSSTable(compress1, compress2, oneFile bool, N, M, maxSSTlevel int) bool {\r\n\r\n\tdataList := mem.SortDataTypes()\r\n\tnewSstableName, _ := LSM.FindNextDestination(0, maxSSTlevel)\r\n\tSSTable.NewSSTable(dataList, N, M, newSstableName, compress1, compress2, oneFile)\r\n\tSSTable.ReadSSTable(newSstableName, compress1, compress2)\r\n\r\n\tmem.data = make(map[string]*datatype.DataType)\r\n\tmem.length = 0\r\n\tmem.readOnly = false\r\n\treturn true\r\n}\r\n\r\nfunc (mem *HashMemtable) UpdateElement(key string, data []byte, time time.Time) {\r\n\tmem.data[key].UpdateDataType(data, time)\r\n}\r\n\r\nfunc (mem *HashMemtable) AddElement(key string, data []byte, time time.Time) bool {\r\n\t//ukoliko ima mesta u memtable, samo se upisuje podatak\r\n\tif mem.length < mem.capacity {\r\n\t\te := datatype.CreateDataType(key, data, time)\r\n\t\tmem.data[key] = e\r\n\t\tmem.length++\r\n\r\n\t\t//ako je popunjen, postavlja se na read only\r\n\t}\r\n\tif mem.length == mem.capacity {\r\n\t\tmem.readOnly = true\r\n\t}\r\n\tif mem.IsReadOnly() {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (mem *HashMemtable) GetElement(key string) (bool, []byte) {\r\n\telem, err := mem.data[key]\r\n\tif !err || elem.IsDeleted() {\r\n\t\treturn false, nil\r\n\t}\r\n\treturn true, elem.GetData()\r\n}\r\n\r\nfunc (mem *HashMemtable) DeleteElement(key string, time time.Time) bool {\r\n\telem, found := mem.data[key]\r\n\tif found {\r\n\t\telem.DeleteDataType(time)\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n\r\nfunc (mem *HashMemtable) IsReadOnly() bool {\r\n\treturn mem.readOnly\r\n}\r\n\r\nfunc (mem *HashMemtable) GetElementByPrefix(dataList []*datatype.DataType, n *int, prefix string) {\r\n\r\n\t//for key, value := range mem.data {\r\n\t//\tif strings.HasPrefix(key, prefix) && !value.IsDeleted() {\r\n\t//\t\tif *n == 0 {\r\n\t//\t\t\treturn\r\n\t//\t\t}\r\n\t//\t\tdataList = append(dataList, value)\r\n\t//\t\t*n--\r\n\t//\t}\r\n\t//}\r\n\tfor key, value := range mem.data {\r\n\t\tif strings.HasPrefix(key, prefix) && !value.IsDeleted() {\r\n\t\t\tif *n == 0 {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tdataList = append(dataList, value)\r\n\t\t\t*n--\r\n\t\t}\r\n\t}\r\n\r\n}\r\nfunc (mem *HashMemtable) GetElementByRange(dataList []*datatype.DataType, n *int, valRange []string) {\r\n\r\n\tfor key, value := range mem.data {\r\n\r\n\t\tif isInRange(key, valRange) && !value.IsDeleted() {\r\n\t\t\tif *n == 0 {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tdataList = append(dataList, value)\r\n\t\t\t*n--\r\n\t\t}\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mem/memtable/hash/hashstruct/hashmem.go b/mem/memtable/hash/hashstruct/hashmem.go
--- a/mem/memtable/hash/hashstruct/hashmem.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/mem/memtable/hash/hashstruct/hashmem.go	(date 1707059871576)
@@ -79,18 +79,15 @@
 	if mem.length == mem.capacity {
 		mem.readOnly = true
 	}
-	if mem.IsReadOnly() {
-		return true
-	}
-	return false
+	return mem.IsReadOnly()
 }
 
-func (mem *HashMemtable) GetElement(key string) (bool, []byte) {
+func (mem *HashMemtable) GetElement(key string) (bool, *datatype.DataType) {
 	elem, err := mem.data[key]
-	if !err || elem.IsDeleted() {
+	if !err {
 		return false, nil
 	}
-	return true, elem.GetData()
+	return true, elem
 }
 
 func (mem *HashMemtable) DeleteElement(key string, time time.Time) bool {
Index: mem/memtable/hash/hashmem/memtable.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package hashmem\r\n\r\nimport (\r\n\t\"sstable/mem/memtable/datatype\"\r\n\t\"time\"\r\n)\r\n\r\ntype Memtable interface {\r\n\t/*\r\n\t\tukoliko se posle dodavanja novog zapisa popuni memtable vraca se true\r\n\t\tu suprotnom se vraca false\r\n\t*/\r\n\tAddElement(key string, data []byte, time time.Time) bool\r\n\tUpdateElement(key string, data []byte, time time.Time)\r\n\tGetElement(key string) (bool, []byte)\r\n\tDeleteElement(key string, time time.Time) bool\r\n\tSortDataTypes() []datatype.DataType\r\n\tGetSortedDataTypes() []datatype.DataType\r\n\tGetMaxSize() int\r\n\t/*\r\n\t\tZapisi iz memtable se sortiraju i upisuju na disk\r\n\t\tPotom se memtable \"prazni\" postavljanjem broja elemenata na 0, kreiranjem prazne strukture i postavljanjem ReadOnly na false\r\n\t*/\r\n\tSendToSSTable(compress1, compress2, oneFile bool, N, M, maxSSTlevel int) bool\r\n\tIsReadOnly() bool\r\n\tGetElementByPrefix(resultList []*datatype.DataType, n *int, prefix string)\r\n\tGetElementByRange(resultList []*datatype.DataType, n *int, valRange []string)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mem/memtable/hash/hashmem/memtable.go b/mem/memtable/hash/hashmem/memtable.go
--- a/mem/memtable/hash/hashmem/memtable.go	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/mem/memtable/hash/hashmem/memtable.go	(date 1707059846644)
@@ -12,7 +12,7 @@
 	*/
 	AddElement(key string, data []byte, time time.Time) bool
 	UpdateElement(key string, data []byte, time time.Time)
-	GetElement(key string) (bool, []byte)
+	GetElement(key string) (bool, *datatype.DataType)
 	DeleteElement(key string, time time.Time) bool
 	SortDataTypes() []datatype.DataType
 	GetSortedDataTypes() []datatype.DataType
Index: EncodedKeys.bin
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\u0000\u0000\u0000\u00012\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u00018\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u00014\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u00017\u0000\u0000\u0000\u0006\u0000\u0000\u0000\u00016\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u00011\u0000\u0000\u0000\b\u0000\u0000\u0000\u00010\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u00015\u0000\u0000\u0000\u0005\u0000\u0000\u0000\u00013\u0000\u0000\u0000\t
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/EncodedKeys.bin b/EncodedKeys.bin
--- a/EncodedKeys.bin	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/EncodedKeys.bin	(date 1707060441801)
@@ -1,1 +1,3 @@
-   2      8      4      7      6      1      0      5      3   	
\ No newline at end of file
+   13   
+   88   X   79   O   65   A   75   K   28      72   H   9   
+   12      5      18      34   "   47   /   49   1   24      62   >   14      81   Q   50   2   17      31      82   R   27      39   '   26      36   $   69   E   60   <   87   W   64   @   11      76   L   52   4   23      63   ?   54   6   33   !   42   *   80   P   40   (   25      85   U   78   N   4      86   V   6      46   .   41   )   43   +   10      59   ;   70   F   37   %   22      7      32       51   3   15      3      55   7   61   =   2      73   I   30      45   -   74   J   20      77   M   56   8   1      44   ,   71   G   57   9   89   Y   66   B   67   C   84   T   58   :   35   #   8   	   53   5   83   S   68   D   21      48   0   19      90   Z   29      38   &   16   
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"ALL\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"1a98e096-3453-4118-8f80-f460cf0ec07e\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/main.go\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.go\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/token_bucket/requests.bin\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/token_bucket/requests.bin\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/wal_implementation/wal/wal_00001.log\" beforeDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"GOROOT\" url=\"file://C:/Program Files/Go\" />\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$/..\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;customColor&quot;: &quot;&quot;,\r\n  &quot;associatedIndex&quot;: 0\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2bii3CizfFpVM3Jq8IQ2U2z9P2B\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.go.formatter.settings.were.checked&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.go.migrated.go.modules.settings&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.go.modules.automatic.dependencies.download&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.go.modules.go.list.on.any.changes.was.set&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;lsm&quot;,\r\n    &quot;go.import.settings.migrated&quot;: &quot;true&quot;,\r\n    &quot;go.sdk.automatically.set&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/Acer&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"go build sstable\" type=\"GoApplicationRunConfiguration\" factoryName=\"Go Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"structs\" />\r\n      <working_directory value=\"$PROJECT_DIR$\" />\r\n      <kind value=\"PACKAGE\" />\r\n      <package value=\"sstable\" />\r\n      <directory value=\"$PROJECT_DIR$\" />\r\n      <filePath value=\"$PROJECT_DIR$/main.go\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Go Build.go build sstable\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"VgoProject\">\r\n    <settings-migrated>true</settings-migrated>\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" type=\"DlvLineBreakpoint\">\r\n          <url>file://$PROJECT_DIR$/LSM/get.go</url>\r\n          <line>34</line>\r\n          <option name=\"timeStamp\" value=\"24\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"DlvLineBreakpoint\">\r\n          <url>file://$PROJECT_DIR$/SSTableStruct/SSTable/search.go</url>\r\n          <line>340</line>\r\n          <option name=\"timeStamp\" value=\"25\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7bcfec1a25bd9e0a7a7155f6d613694f3fc0fcdc)
+++ b/.idea/workspace.xml	(date 1707060522976)
@@ -6,8 +6,17 @@
   <component name="ChangeListManager">
     <list default="true" id="1a98e096-3453-4118-8f80-f460cf0ec07e" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/EncodedKeys.bin" beforeDir="false" afterPath="$PROJECT_DIR$/EncodedKeys.bin" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/LSM/lsm.go" beforeDir="false" afterPath="$PROJECT_DIR$/LSM/lsm.go" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/config.json" beforeDir="false" afterPath="$PROJECT_DIR$/config.json" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/cursor/cursor.go" beforeDir="false" afterPath="$PROJECT_DIR$/cursor/cursor.go" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/main.go" beforeDir="false" afterPath="$PROJECT_DIR$/main.go" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mem/memtable/btree/btreemem/btreememstruct.go" beforeDir="false" afterPath="$PROJECT_DIR$/mem/memtable/btree/btreemem/btreememstruct.go" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mem/memtable/hash/hashmem/memtable.go" beforeDir="false" afterPath="$PROJECT_DIR$/mem/memtable/hash/hashmem/memtable.go" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mem/memtable/hash/hashstruct/hashmem.go" beforeDir="false" afterPath="$PROJECT_DIR$/mem/memtable/hash/hashstruct/hashmem.go" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/mem/memtable/skiplist/skiplistmem/skiplistmemtable.go" beforeDir="false" afterPath="$PROJECT_DIR$/mem/memtable/skiplist/skiplistmem/skiplistmemtable.go" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/token_bucket/requests.bin" beforeDir="false" afterPath="$PROJECT_DIR$/token_bucket/requests.bin" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/wal_implementation/EndsOfMemtables.bin" beforeDir="false" afterPath="$PROJECT_DIR$/wal_implementation/EndsOfMemtables.bin" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/wal_implementation/wal/wal_00001.log" beforeDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -46,6 +55,15 @@
   }
 }</component>
   <component name="RunManager">
+    <configuration default="true" type="GoApplicationRunConfiguration" factoryName="Go Application">
+      <module name="structs" />
+      <working_directory value="$PROJECT_DIR$" />
+      <kind value="PACKAGE" />
+      <package value="sstable" />
+      <directory value="$PROJECT_DIR$" />
+      <filePath value="$PROJECT_DIR$" />
+      <method v="2" />
+    </configuration>
     <configuration name="go build sstable" type="GoApplicationRunConfiguration" factoryName="Go Application" temporary="true" nameIsGenerated="true">
       <module name="structs" />
       <working_directory value="$PROJECT_DIR$" />
@@ -80,6 +98,11 @@
           <url>file://$PROJECT_DIR$/SSTableStruct/SSTable/search.go</url>
           <line>340</line>
           <option name="timeStamp" value="25" />
+        </line-breakpoint>
+        <line-breakpoint enabled="true" type="DlvLineBreakpoint">
+          <url>file://$PROJECT_DIR$/main.go</url>
+          <line>318</line>
+          <option name="timeStamp" value="35" />
         </line-breakpoint>
       </breakpoints>
     </breakpoint-manager>
